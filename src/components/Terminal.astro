---
// Interactive terminal with typing animation - auto-starts
---

<section id="demo" class="py-16 md:py-24 relative">
  <div class="absolute inset-0 bg-gradient-to-b from-transparent via-tokyo-bg-dark/30 to-transparent"></div>

  <div class="relative max-w-4xl mx-auto px-4">
    <h2 class="text-2xl md:text-3xl font-mono font-bold text-tokyo-text mb-2 text-center">
      <span class="text-tokyo-cyan">~</span> See it in action
    </h2>
    <p class="text-tokyo-text-dim text-center mb-8 text-sm">Watch ssl-toolkit analyze certificates in real-time</p>

    <!-- Terminal Window -->
    <div class="terminal-window rounded-xl overflow-hidden relative crt-scan">
      <!-- Title Bar -->
      <div class="flex items-center gap-2 px-4 py-3 bg-tokyo-bg-dark/80 border-b border-tokyo-border/50">
        <div class="flex gap-2">
          <div class="w-3 h-3 rounded-full bg-tokyo-red/80 hover:bg-tokyo-red transition-colors"></div>
          <div class="w-3 h-3 rounded-full bg-tokyo-orange/80 hover:bg-tokyo-orange transition-colors"></div>
          <div class="w-3 h-3 rounded-full bg-tokyo-green/80 hover:bg-tokyo-green transition-colors"></div>
        </div>
        <div class="flex-1 text-center">
          <span class="text-[11px] font-mono text-tokyo-text-dim/60">ssl-toolkit &mdash; bash &mdash; 80x24</span>
        </div>
        <div class="w-[52px]"></div>
      </div>

      <!-- Terminal Body -->
      <div class="bg-tokyo-bg-dark p-4 md:p-5 font-mono text-[11px] md:text-[12px] h-[420px] overflow-y-auto relative scanlines leading-[1.5]" id="terminal-container">
        <div id="terminal-output"></div>
        <span id="terminal-cursor" class="cursor-blink text-tokyo-green inline">â–ˆ</span>
      </div>
    </div>
  </div>
</section>

<script>
  interface LinePart {
    text: string;
    cls?: string;
    typed?: boolean;
  }

  interface Line {
    text?: string;
    cls?: string;
    pause?: number;
    parts?: LinePart[];
    clear?: boolean;
  }

  interface Scenario {
    lines: Line[];
  }

  interface TerminalConfig {
    colorMap: Record<string, string>;
    scenarios: Scenario[];
  }

  const output = document.getElementById('terminal-output')!;
  const container = document.getElementById('terminal-container')!;
  let running = true;
  let colorMap: Record<string, string> = {};
  let scenarios: Scenario[] = [];

  function sleep(ms: number) { return new Promise(r => setTimeout(r, ms)); }

  function appendText(html: string) {
    output.insertAdjacentHTML('beforeend', html);
    container.scrollTop = container.scrollHeight;
  }

  async function typeText(text: string, style: string) {
    for (const ch of text) {
      appendText(ch === ' ' ? ' ' : `<span style="${style}">${ch}</span>`);
      await sleep(30 + Math.random() * 20);
    }
  }

  function renderPart(part: LinePart): string {
    return `<span style="${colorMap[part.cls || ''] || ''}">${part.text}</span>`;
  }

  async function renderLine(line: Line): Promise<void> {
    if (line.clear) {
      output.innerHTML = '';
      return;
    }

    if (line.parts) {
      for (const part of line.parts) {
        if (part.typed) {
          await typeText(part.text, colorMap[part.cls || ''] || '');
        } else {
          appendText(renderPart(part));
        }
      }
      appendText('\n');
      return;
    }

    if (line.text === '' || line.text === undefined) {
      appendText('\n');
      return;
    }

    appendText(`<span style="${colorMap[line.cls || ''] || ''}">${line.text}</span>\n`);
  }

  async function playScenario(scenario: Scenario) {
    for (const line of scenario.lines) {
      const pause = line.pause || 60;
      await sleep(pause);
      await renderLine(line);
    }
  }

  async function run() {
    // Fetch config from external JSON file
    try {
      const response = await fetch('/config/terminal-demo.json');
      const config: TerminalConfig = await response.json();
      colorMap = config.colorMap;
      scenarios = config.scenarios;
    } catch (error) {
      console.error('Failed to load terminal demo config:', error);
      return;
    }

    let idx = 0;
    while (running) {
      output.innerHTML = '';
      await sleep(400);
      await playScenario(scenarios[idx]);
      await sleep(4000);
      idx = (idx + 1) % scenarios.length;
    }
  }

  // Start immediately - no intersection observer delay
  run();
</script>
